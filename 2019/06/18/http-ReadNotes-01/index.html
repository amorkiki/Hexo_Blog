<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>http_ReadNotes-01 - Amorki&#39;s</title>
    <meta name="author" content="">
    
	<meta name="description" content="&lt;blockquote&gt;
&lt;p&gt;web开发中可能会用到用到 HTTP 协议的各方面知识 の 工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写网络爬虫phyton程序&lt;/li&gt;
&lt;li&gt;分析抓包数据&lt;/li&gt;
&lt;li&gt;实现 HTTP 服务器&lt;/li&gt;
&lt;li&gt;提供网站 REST API&lt;/li&gt;
&lt;li&gt;修改后端定制框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;I-web及网络基础&#34;&gt;&lt;a href=&#34;#I-web及网络基础&#34; class=&#34;headerlink&#34; title=&#34;I. web及网络基础&#34;&gt;&lt;/a&gt;I. web及网络基础&lt;/h1&gt;&lt;p&gt;==HTTP    (HyperText Transfer Protocol）   超文本传输协议== &lt;/p&gt;
&lt;h2 id=&#34;1-1-HTTP-协议访问-Web&#34;&gt;&lt;a href=&#34;#1-1-HTTP-协议访问-Web&#34; class=&#34;headerlink&#34; title=&#34;1.1  HTTP 协议访问 Web&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.1&lt;/strong&gt;  &lt;strong&gt;HTTP&lt;/strong&gt; 协议访问 Web&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Web 是建立在 HTTP 协议上通信的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9e5n5837j30if080gm2.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据指定的URL，web浏览器从web服务器获取相应资源（resource），然后呈现在web页面上，实现这种功能的web浏览器is—-&lt;code&gt;客户端(client)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9e9fsd4wj30hq05474o.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完成这一系列事件，需要遵循一种规则约定—-超文本传输协议 is &lt;code&gt;HTTP&lt;/code&gt; Hyper Text Transfer Protocol。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-2-WWW-构建技术&#34;&gt;&lt;a href=&#34;#1-2-WWW-构建技术&#34; class=&#34;headerlink&#34; title=&#34;1.2 WWW 构建技术&#34;&gt;&lt;/a&gt;1.2 WWW 构建技术&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;HTML&lt;/code&gt; ： 把 &lt;code&gt;SGML&lt;/code&gt;(Standard Generalized Markup Language，标准通用标记语言)  作为页面的文本标 记语言的 &lt;code&gt;HTML&lt;/code&gt;(HyperText Markup Language，超文本标记语言);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP&lt;/code&gt; ：作为文档传递协议的 HTTP。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URL&lt;/code&gt; ：指定文档所在地址- URL(Uniform Resource Locator，统一资源定位符)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-3网络基础-TCP-IP&#34;&gt;&lt;a href=&#34;#1-3网络基础-TCP-IP&#34; class=&#34;headerlink&#34; title=&#34;1.3网络基础  TCP/IP&#34;&gt;&lt;/a&gt;1.3网络基础  TCP/IP&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通常使用的 网络(包括互联网)是在  &lt;code&gt;TCP/IP 协议族&lt;/code&gt;的基础上运作的。而 HTTP 属于它内部的一个子集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-3-1-TCP-IP-协议族&#34;&gt;&lt;a href=&#34;#1-3-1-TCP-IP-协议族&#34; class=&#34;headerlink&#34; title=&#34;1.3.1 TCP/IP 协议族&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.3.1&lt;/strong&gt; &lt;strong&gt;TCP/IP&lt;/strong&gt; 协议族&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9en3wyyzj30hz08jglz.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;图:&lt;strong&gt;TCP/IP&lt;/strong&gt; 是互联网相关的各类协议族的总称&lt;/p&gt;
&lt;h3 id=&#34;1-3-2-TCP-IP-的分层管理&#34;&gt;&lt;a href=&#34;#1-3-2-TCP-IP-的分层管理&#34; class=&#34;headerlink&#34; title=&#34;1.3.2 TCP/IP 的分层管理&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.3.2&lt;/strong&gt; &lt;strong&gt;TCP/IP&lt;/strong&gt; 的分层管理&lt;/h3&gt;&lt;p&gt;TCP/IP 协议族按  层次  分为 4 层:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;应用层&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;决定了向用户&lt;u&gt;提供应用服务时的通信活动&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;TCP/IP 协议族内预存了各类通用的应用服务。&lt;br&gt;如：&lt;code&gt;FTP&lt;/code&gt;(File Transfer Protocol，文件传输协议)、&lt;br&gt;&lt;code&gt;DNS&lt;/code&gt;(Domain Name System，域名系统) 服务&lt;/li&gt;
&lt;li&gt;HTTP 协议也处于该层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;传输层&lt;/code&gt; ：&lt;ul&gt;
&lt;li&gt;对上层应用层，&lt;u&gt;提供处于网络连接中的两台计算机之间的数据传输&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;两个性质不同的协议:&lt;br&gt;&lt;code&gt;TCP&lt;/code&gt;(Transmission Control Protocol，传输控制协议)&lt;br&gt;&lt;code&gt;UDP&lt;/code&gt;(User Data Protocol，用户数据报协议)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;网络层&lt;/code&gt; ：&lt;ul&gt;
&lt;li&gt;处理在网络上流动的数据包，&lt;u&gt;数据包是网络传输的最小数据单位&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;规定了&lt;u&gt;通过怎样的路径&lt;/u&gt;(所谓的传输路线)到达对方计算机，并&lt;u&gt;把数据包传送给对方&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;与对方计算机之间&lt;u&gt;通过多台计算机或网络设备进行传输时&lt;/u&gt;，–&lt;u&gt;在众多的选项内选择一条传输路线&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据链路层&lt;/code&gt; ：（网络接口层）&lt;ul&gt;
&lt;li&gt;处理连接网络的硬件部分，包括–&lt;br&gt;&lt;u&gt;控制操作系统&lt;/u&gt;、&lt;br&gt;&lt;u&gt;硬件的设备驱动&lt;/u&gt;&lt;br&gt;&lt;code&gt;NIC&lt;/code&gt;(Network Interface Card，网络适配器，即网卡)&lt;br&gt;&lt;u&gt;光纤等物理可见部分&lt;/u&gt;(还包括连接器等一切传输媒介)。&lt;/li&gt;
&lt;li&gt;硬件上的范畴均在链路层的作用范围之内。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这样一来：要改变设计时，只需把变动的那层替换掉即可。&lt;/p&gt;
&lt;p&gt;把各层之间的接口部分规划好之 后，每个层次内部的设计就能够自由改动了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-3-3-TCP-IP-通信传输流&#34;&gt;&lt;a href=&#34;#1-3-3-TCP-IP-通信传输流&#34; class=&#34;headerlink&#34; title=&#34;1.3.3 TCP/IP 通信传输流&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.3.3&lt;/strong&gt; &lt;strong&gt;TCP/IP&lt;/strong&gt; 通信传输流&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9f2itcrej30i90e0wf5.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;发送端从应用层往下走，接收端则往应用层往上走。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发出HTTP请求 &lt;/p&gt;
&lt;p&gt;​    👇&lt;/p&gt;
&lt;p&gt;TCP协议把HTTP 请求报文进行分割 ，打上标记序号、端口号&lt;/p&gt;
&lt;p&gt;​    👇&lt;/p&gt;
&lt;p&gt;IP 协议增加MAC 地址(作为&lt;u&gt;通信目的地&lt;/u&gt;的 )后转发给链路层&lt;/p&gt;
&lt;p&gt;​    👇&lt;/p&gt;
&lt;p&gt;这样一来，发往网络的通信请求就准备齐全了。&lt;/p&gt;
&lt;p&gt;​    👇&lt;/p&gt;
&lt;p&gt;接收端的服务器在链路层接收到数据，按序往上层发送&lt;/p&gt;
&lt;p&gt;​    👇&lt;/p&gt;
&lt;p&gt;当传输到应用层，才算真正接收到由客端发送过来的 HTTP 请求👩&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9fbm9tolj30i80fvdh9.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;发送端在层与层之间传输数据时，每经过一层时必定会被打上一个==该层所属的首部信息==。&lt;/p&gt;
&lt;p&gt;接收端在层与层传输数据时，每经过一层时会把对应的首部消去。&lt;/p&gt;
&lt;p&gt;这种==把数据信息包装起来==的做法称为&lt;code&gt;封装&lt;/code&gt;(encapsulate)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-4-IP、TCP-和-DNS-—与-HTTP-关系密切&#34;&gt;&lt;a href=&#34;#1-4-IP、TCP-和-DNS-—与-HTTP-关系密切&#34; class=&#34;headerlink&#34; title=&#34;1.4  IP、TCP 和 DNS —与 HTTP 关系密切&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.4&lt;/strong&gt;  IP、TCP 和 DNS —与 &lt;strong&gt;HTTP&lt;/strong&gt; 关系密切&lt;/h2&gt;&lt;h3 id=&#34;1-4-1-负责传输的-IP-协议&#34;&gt;&lt;a href=&#34;#1-4-1-负责传输的-IP-协议&#34; class=&#34;headerlink&#34; title=&#34;1.4.1 负责传输的 IP 协议&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.4.1&lt;/strong&gt; 负责传输的 &lt;strong&gt;IP&lt;/strong&gt; 协议&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;IP 地址&lt;/code&gt;  ：指明了节点被分配到的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MAC 地址&lt;/code&gt;(Media Access Control Address) ：网卡所属的固定地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IP 地址可以和 MAC 地址进行配对；IP 地址可变换，MAC 地址基本上不会更改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IP 间的通信依赖 MAC 地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在网络上，通信的双方在同一局域网 (LAN)内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。&lt;/p&gt;
&lt;p&gt;而在进行&lt;u&gt;中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;这时，会采用 &lt;code&gt;ARP 协议&lt;/code&gt;(Address Resolution Protocol)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ARP&lt;/code&gt; 是用来  **&lt;u&gt;解析地址&lt;/u&gt;**的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;路由选择(routing)&lt;/code&gt; ：在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。这种机制称为路由选择(routing)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9gfsicbwj30hh0g075q.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-4-2-确保可靠性的-TCP-协议&#34;&gt;&lt;a href=&#34;#1-4-2-确保可靠性的-TCP-协议&#34; class=&#34;headerlink&#34; title=&#34;1.4.2 确保可靠性的 TCP 协议&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.4.2&lt;/strong&gt; 确保可靠性的 &lt;strong&gt;TCP&lt;/strong&gt; 协议&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;TCP 位于传输层，提供可靠的字节流服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;字节流服务&lt;/code&gt;— 将大块数据分割成以报文段(segment)为单位的数据包进行管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TCP 协议为 了更容易传送大数据才把数据分割；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TCP 协议能够确认数据最终是否送达到对方： &lt;code&gt;三次握手(three-way handshaking)策略&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包送出去后，TCP会向对方确认是否成功送达；&lt;/li&gt;
&lt;li&gt;握手过程使用：&lt;ul&gt;
&lt;li&gt;TCP 的标志(flag) &lt;/li&gt;
&lt;li&gt;SYN(synchronize) &lt;/li&gt;
&lt;li&gt;ACK(acknowledgement)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SNY ➡️&lt;/p&gt;
&lt;p&gt;​        ⬅️ SNY/ACK&lt;/p&gt;
&lt;p&gt;ACK➡️   &lt;/p&gt;
&lt;p&gt;​                    &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9glwue5cj30hg09p3za.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-5-负责域名解析的-DNS-服务&#34;&gt;&lt;a href=&#34;#1-5-负责域名解析的-DNS-服务&#34; class=&#34;headerlink&#34; title=&#34;1.5 负责域名解析的 DNS 服务&#34;&gt;&lt;/a&gt;1.5 负责域名解析的 &lt;strong&gt;DNS&lt;/strong&gt; 服务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt;(Domain Name System)提供&lt;strong&gt;域名&lt;/strong&gt;到 IP 地址之间的&lt;strong&gt;解析服务&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;u&gt;计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户通常使用&lt;code&gt;主机名&lt;/code&gt;或&lt;code&gt;域名&lt;/code&gt;来访问对方的计算机&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9h2hmrbjj30he0bbaay.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-6-各种协议与-HTTP-协议的关系&#34;&gt;&lt;a href=&#34;#1-6-各种协议与-HTTP-协议的关系&#34; class=&#34;headerlink&#34; title=&#34;1.6 各种协议与 HTTP 协议的关系&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.6&lt;/strong&gt; 各种协议与 &lt;strong&gt;HTTP&lt;/strong&gt; 协议的关系&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9h85ouxyj30ft0mswgr.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-7-URI-和-URL&#34;&gt;&lt;a href=&#34;#1-7-URI-和-URL&#34; class=&#34;headerlink&#34; title=&#34;1.7 URI 和 URL&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.7&lt;/strong&gt; &lt;strong&gt;URI&lt;/strong&gt; 和 &lt;strong&gt;URL&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;URI&lt;/code&gt;  Uniform Resource Identifier   统一资源标识符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由某个协议方案表示的资源的定位标识符。&lt;/li&gt;
&lt;li&gt;协议方案是指  访问资源所使用的协议类型名称；采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、mailto、telnet、file 等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URI&lt;/code&gt; 用字符串标识某一互联网资源，而 &lt;code&gt;URL&lt;/code&gt; 表示资源的地点(互联 网上所处的位置)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;URI-格式&#34;&gt;&lt;a href=&#34;#URI-格式&#34; class=&#34;headerlink&#34; title=&#34;URI 格式&#34;&gt;&lt;/a&gt;&lt;strong&gt;URI&lt;/strong&gt; 格式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;绝对 URI &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gf9icxnnjvj30g703twer.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。&lt;/p&gt;
&lt;p&gt;不区分字母大小写，最后附一个冒号(:)。&lt;/p&gt;
&lt;p&gt;也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;📟-登录信息-认证&#34;&gt;&lt;a href=&#34;#📟-登录信息-认证&#34; class=&#34;headerlink&#34; title=&#34;📟 登录信息(认证)&#34;&gt;&lt;/a&gt;📟 登录信息(认证)&lt;/h5&gt;&lt;p&gt;指定用户名和密码作为从服务器端获取资源时必要的登录信息(身份认证)。此项是可选项。&lt;/p&gt;
&lt;h5 id=&#34;✉️-服务器地址&#34;&gt;&lt;a href=&#34;#✉️-服务器地址&#34; class=&#34;headerlink&#34; title=&#34;✉️  服务器地址&#34;&gt;&lt;/a&gt;✉️  服务器地址&lt;/h5&gt;&lt;p&gt;使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 &lt;code&gt;DNS&lt;/code&gt; 可解析的名称，或是 192.168.1.1 这类 &lt;code&gt;IPv4&lt;/code&gt; 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 &lt;code&gt;IPv6&lt;/code&gt; 地址名。&lt;/p&gt;
&lt;h5 id=&#34;🕰-服务器端口号&#34;&gt;&lt;a href=&#34;#🕰-服务器端口号&#34; class=&#34;headerlink&#34; title=&#34;🕰 服务器端口号&#34;&gt;&lt;/a&gt;🕰 服务器端口号&lt;/h5&gt;&lt;p&gt;指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动 使用默认端口号。&lt;/p&gt;
&lt;h5 id=&#34;📑-带层次的文件路径&#34;&gt;&lt;a href=&#34;#📑-带层次的文件路径&#34; class=&#34;headerlink&#34; title=&#34;📑 带层次的文件路径&#34;&gt;&lt;/a&gt;📑 带层次的文件路径&lt;/h5&gt;&lt;p&gt;指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。&lt;/p&gt;
&lt;h5 id=&#34;🔑-查询字符串&#34;&gt;&lt;a href=&#34;#🔑-查询字符串&#34; class=&#34;headerlink&#34; title=&#34;🔑 查询字符串&#34;&gt;&lt;/a&gt;🔑 查询字符串&lt;/h5&gt;&lt;p&gt;针对已指定的文件路径内的资源，可以使用查询字符串传入任意参 数。此项可选。&lt;/p&gt;
&lt;h5 id=&#34;🔫-片段标识符&#34;&gt;&lt;a href=&#34;#🔫-片段标识符&#34; class=&#34;headerlink&#34; title=&#34;🔫 片段标识符&#34;&gt;&lt;/a&gt;🔫 片段标识符&lt;/h5&gt;&lt;p&gt;使用片段标识符通常可标记出已获取资源中的子资源(文档内的某个位置)。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一些用来制定 HTTP 协议技术标准的文档，它们被称为&lt;code&gt;RFC&lt;/code&gt;(Request for Comments，征求修正意见书)。&lt;/p&gt;
&lt;p&gt;并不是所有的应用程序都符合 RFC&lt;/p&gt;
&lt;p&gt;RFC 是 互联网的设计文档，要是不按照 RFC 标准执行，就有可能导致无法通信的状况。&lt;/p&gt;
&lt;p&gt;基本 上客户端和服务器端都会以 RFC 为标准来实现 HTTP 协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;II-简单的-HTTP-协议&#34;&gt;&lt;a href=&#34;#II-简单的-HTTP-协议&#34; class=&#34;headerlink&#34; title=&#34;II.简单的 HTTP 协议&#34;&gt;&lt;/a&gt;II.简单的 HTTP 协议&lt;/h1&gt;&lt;h2 id=&#34;2-1-HTTP-协议作用&#34;&gt;&lt;a href=&#34;#2-1-HTTP-协议作用&#34; class=&#34;headerlink&#34; title=&#34;2.1 HTTP 协议作用&#34;&gt;&lt;/a&gt;2.1 &lt;strong&gt;HTTP&lt;/strong&gt; 协议作用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt; 协议用于客户端和服务器端之间的&lt;code&gt;通信&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;请求访问文本或图像等资源的一端称为&lt;code&gt;客户端&lt;/code&gt;，而提供资源响应的一 端称为&lt;code&gt;服务器端&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfomjb1s01j30jx07zt9e.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;两台计算机作为客户端和服务器端的&lt;u&gt;角色有可能会互换&lt;/u&gt;。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器端。&lt;/p&gt;
&lt;h2 id=&#34;2-2-How达成通信&#34;&gt;&lt;a href=&#34;#2-2-How达成通信&#34; class=&#34;headerlink&#34; title=&#34;2.2 How达成通信&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.2&lt;/strong&gt; How达成通信&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;请求和响应的交换&lt;/code&gt;达成通信&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfommtf5i8j30jk074q3k.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfomnk9uoij30k90acgmd.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端发送给某个 HTTP 服务器端的请求报文中&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET&lt;/code&gt;—— 请求访问服务器的类型，称为方法 (method)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;字符串 /index.htm&lt;/code&gt; ——-请求访问的资源对象， 也叫做请求 URI(request-URI)。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;HTTP/1.1&lt;/code&gt;—— HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。&lt;/p&gt;
&lt;p&gt;综合来看，这段请求内容的意思是:&lt;u&gt;请求访问某台 HTTP 服务器上的 /index.htm 页面资源。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;请求报文&lt;/code&gt;是由==请求方法==、==请求 URI==、==协议版本==、==可选的请求首部字段== 和内==容实体==构成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfomrgipocj30k60azgm8.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收到请求的服务器，会将请求内容的处理结果以响应的形式返回：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;HTTP/1.1&lt;/code&gt; 表示服务器对应的 HTTP 版本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;200 OK&lt;/code&gt; 表示请求的处理结果的状态码(status code)和原因短语(reason-phrase)。&lt;/p&gt;
&lt;p&gt;下一行显示了创建响应的日期时间，是首部字段(header field)内的一个属性。&lt;/p&gt;
&lt;p&gt;接着以一空行分隔，之后的内容称为&lt;code&gt;资源实体的主体&lt;/code&gt;(entity body)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;响应报文&lt;/code&gt;基本上由==协议版本==、==状态码(表示请求成功或失败的数字代码)==、==用以解释状态码的原因短语==、==可选的响应首部字段==以及==实体主体==构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfomutu23fj30k20awaal.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-3-HTTP-是不保存状态的协议&#34;&gt;&lt;a href=&#34;#2-3-HTTP-是不保存状态的协议&#34; class=&#34;headerlink&#34; title=&#34;2.3 HTTP 是不保存状态的协议&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.3&lt;/strong&gt; &lt;strong&gt;HTTP&lt;/strong&gt; 是不保存状态的协议&lt;/h2&gt;&lt;p&gt;HTTP 是一种不保存状态，即&lt;code&gt;无状态(stateless)协议&lt;/code&gt;。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。&lt;/p&gt;
&lt;p&gt;这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设 计成如此简单的。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 &lt;code&gt;Cookie 技术&lt;/code&gt;。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。&lt;/p&gt;
&lt;h2 id=&#34;2-4-请求-URI-定位资源&#34;&gt;&lt;a href=&#34;#2-4-请求-URI-定位资源&#34; class=&#34;headerlink&#34; title=&#34;2.4 请求 URI 定位资源&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.4&lt;/strong&gt; 请求 &lt;strong&gt;URI&lt;/strong&gt; 定位资源&lt;/h2&gt;&lt;p&gt;HTTP 协议使用 &lt;strong&gt;URI 定位互联网上的资源&lt;/strong&gt;。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfomywnmktj30js0em0u5.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;当客户端请求访问资源而发送请求时，&lt;strong&gt;URI 需要将作为请求报文中的请求 URI 包含在内&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定请求 URI 的方式&lt;/strong&gt;有很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfomzmqy4sj30jn0a5mxp.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果不是访问特定资源而是对服务器本身发起请求，可以 用一个 * 来代替请求 URI。&lt;/p&gt;
&lt;p&gt;下面这个例子是查询 HTTP 服务器端支持 的 HTTP 方法种类。&lt;/p&gt;
&lt;p&gt;OPTIONS * HTTP/1.1&lt;/p&gt;
&lt;h2 id=&#34;2-5-告知服务器意图的-HTTP-方法&#34;&gt;&lt;a href=&#34;#2-5-告知服务器意图的-HTTP-方法&#34; class=&#34;headerlink&#34; title=&#34;2.5 告知服务器意图的 HTTP 方法&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.5&lt;/strong&gt; 告知服务器意图的 &lt;strong&gt;HTTP&lt;/strong&gt; 方法&lt;/h2&gt;&lt;h3 id=&#34;GET-获取资源&#34;&gt;&lt;a href=&#34;#GET-获取资源&#34; class=&#34;headerlink&#34; title=&#34;GET :获取资源&#34;&gt;&lt;/a&gt;&lt;strong&gt;GET&lt;/strong&gt; :获取资源&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;==请求访问已被 URI 识别的资源==&lt;/li&gt;
&lt;li&gt;指定的资源经服务器端解析后返回响应内容。&lt;/li&gt;
&lt;li&gt;如果请求的资源是文本，那就保持原样返回;如果是像 CGI(Common Gateway Interface，通用网关接 口)那样的程序，则返回经过执行后的输出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfon42wnpfj30g7060mxc.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfon4f24taj30lc09pq3m.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;POST-传输实体主体&#34;&gt;&lt;a href=&#34;#POST-传输实体主体&#34; class=&#34;headerlink&#34; title=&#34;POST:传输实体主体&#34;&gt;&lt;/a&gt;&lt;strong&gt;POST&lt;/strong&gt;:传输实体主体&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。&lt;/li&gt;
&lt;li&gt;虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfon6hk66ej30hd061dg0.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfon6pxttjj30hs04omxg.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;PUT-传输文件&#34;&gt;&lt;a href=&#34;#PUT-传输文件&#34; class=&#34;headerlink&#34; title=&#34;PUT:传输文件&#34;&gt;&lt;/a&gt;&lt;strong&gt;PUT&lt;/strong&gt;:传输文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;就像 FTP 协议的文件上传一样，要求&lt;u&gt;在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;鉴于 HTTP/1.1 的 PUT 方法自身&lt;u&gt;不带验证机制&lt;/u&gt;，任何人都可以上传文件 , 存在安全性问题，因此&lt;u&gt;一般的 Web 网站不使用该方法。&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;若配合 Web 应用程序的验证机制，或架构设计采用 REST(REpresentational State Transfer，表征状态转移)标准的同类 Web 网站，就可能会开放使用 PUT 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfon8qkhtdj30ki0cwt9w.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;HEAD-获得报文首部&#34;&gt;&lt;a href=&#34;#HEAD-获得报文首部&#34; class=&#34;headerlink&#34; title=&#34;HEAD:获得报文首部&#34;&gt;&lt;/a&gt;&lt;strong&gt;HEAD&lt;/strong&gt;:获得报文首部&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于&lt;u&gt;确认 URI 的有效性&lt;/u&gt;及&lt;u&gt;资源更新的日期时间&lt;/u&gt;等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfon9zhpr5j30is0893yv.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfona6xjqmj30i804igls.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;DELETE-删除文件&#34;&gt;&lt;a href=&#34;#DELETE-删除文件&#34; class=&#34;headerlink&#34; title=&#34;DELETE:删除文件&#34;&gt;&lt;/a&gt;&lt;strong&gt;DELETE&lt;/strong&gt;:删除文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法&lt;u&gt;按 请求 URI 删除指定的资源。&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样&lt;u&gt;不带验证机制&lt;/u&gt;，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonbcmqytj30jy09naaw.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;OPTIONS-询问支持的方法&#34;&gt;&lt;a href=&#34;#OPTIONS-询问支持的方法&#34; class=&#34;headerlink&#34; title=&#34;OPTIONS:询问支持的方法&#34;&gt;&lt;/a&gt;&lt;strong&gt;OPTIONS&lt;/strong&gt;:询问支持的方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;u&gt;查询针对请求 URI 指定的资源支持的方法&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonbvvjfej30jk070gly.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonc8192qj30iv05qaad.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;TRACE-追踪路径&#34;&gt;&lt;a href=&#34;#TRACE-追踪路径&#34; class=&#34;headerlink&#34; title=&#34;TRACE:追踪路径&#34;&gt;&lt;/a&gt;&lt;strong&gt;TRACE&lt;/strong&gt;:追踪路径&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;u&gt;让 Web 服务器端将之前的请求通信环回给客户端的方法。&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。&lt;/p&gt;
&lt;p&gt;但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST(Cross-Site Tracing，跨站追踪)攻击，通常就更不会用到了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonecee5bj30j60cvmyl.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfoneu42hcj30ip041t8r.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;CONNECT-要求用隧道协议连接代理&#34;&gt;&lt;a href=&#34;#CONNECT-要求用隧道协议连接代理&#34; class=&#34;headerlink&#34; title=&#34;CONNECT:要求用隧道协议连接代理&#34;&gt;&lt;/a&gt;&lt;strong&gt;CONNECT&lt;/strong&gt;:要求用隧道协议连接代理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;要求&lt;u&gt;在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主要使用 SSL(Secure Sockets Layer，安全套接 层)和 TLS(Transport Layer Security，传输层安全)协议把通信内容加密后经网络隧道传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CONNECT 方法的格式如下所示。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONNECT 代理服务器名:端口号 HTTP版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfong1l3d3j30jc0bi3zk.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-6-使用方法下达命令&#34;&gt;&lt;a href=&#34;#2-6-使用方法下达命令&#34; class=&#34;headerlink&#34; title=&#34;2.6 使用方法下达命令&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.6&lt;/strong&gt; 使用方法下达命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;方法的作用在于，&lt;strong&gt;可以指定请求的资源按期望产生某种行为&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;方法中 有 &lt;code&gt;GET&lt;/code&gt;、&lt;code&gt;POST&lt;/code&gt; 和 &lt;code&gt;HEAD&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonh7ww7ij30jq08vwf8.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonhxn0q6j30jt0fhtah.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-7-持久连接节省通信量&#34;&gt;&lt;a href=&#34;#2-7-持久连接节省通信量&#34; class=&#34;headerlink&#34; title=&#34;2.7 持久连接节省通信量&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.7&lt;/strong&gt; 持久连接节省通信量&lt;/h2&gt;&lt;h3 id=&#34;2-7-1-持久连接&#34;&gt;&lt;a href=&#34;#2-7-1-持久连接&#34; class=&#34;headerlink&#34; title=&#34;2.7.1 持久连接&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.7.1&lt;/strong&gt; 持久连接&lt;/h3&gt;&lt;p&gt;持久连接(HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;： 只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonjpakaaj30jr0h90ud.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。&lt;/li&gt;
&lt;li&gt;使 HTTP 请求和响应能够更早地结束，Web 页面的显示速度提高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-7-2-管线化&#34;&gt;&lt;a href=&#34;#2-7-2-管线化&#34; class=&#34;headerlink&#34; title=&#34;2.7.2 管线化&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.7.2&lt;/strong&gt; 管线化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;久连接使得多数请求以管线化(pipelining)方式发送成为可能。&lt;/li&gt;
&lt;li&gt;管线化技术使得 不用等待响应亦可直接发送下一个请求。&lt;/li&gt;
&lt;li&gt;同时并行发送多个请求，而不需要一个接一个地等待响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonn8n2qrj30jr09p752.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-8-使用-Cookie-的状态管理&#34;&gt;&lt;a href=&#34;#2-8-使用-Cookie-的状态管理&#34; class=&#34;headerlink&#34; title=&#34;2.8 使用 Cookie 的状态管理&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.8&lt;/strong&gt; 使用 &lt;strong&gt;Cookie&lt;/strong&gt; 的状态管理&lt;/h3&gt;&lt;p&gt;HTTP 是无状态协议，无法根据之前的状态进行本次的请求处理。不保存状态，减少服务器的 CPU 及内存资源的消耗。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cookie 技术&lt;/code&gt;通过==在请求和响应报文中写入 Cookie 信息来控制客户端的状态==。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据从服务器端发送的响应报文内的 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。&lt;/li&gt;
&lt;li&gt;当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。&lt;/li&gt;
&lt;li&gt;服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonvunolbj30j90ah0te.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gfonwajvvej30j7093wf1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求报文和响应报文的内容:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;请求报文(没有 &lt;strong&gt;Cookie&lt;/strong&gt; 信息的状态)&lt;/p&gt;
&lt;figure class=&#34;highlight&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;GET&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;/reader/&lt;/span&gt; HTTP/1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attribute&#34;&gt;Host&lt;/span&gt;: hackr.jp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;*首部字段内没有Cookie的相关信息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;响应报文(服务器端生成 &lt;strong&gt;Cookie&lt;/strong&gt; 信息)&lt;/p&gt;
&lt;figure class=&#34;highlight http&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;HTTP/1.1 &lt;span class=&#34;number&#34;&gt;200&lt;/span&gt; OK&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attribute&#34;&gt;Date&lt;/span&gt;: Thu, 12 Jul 2012 07:12:20 GMT&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attribute&#34;&gt;Server&lt;/span&gt;: Apache&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-Oct-12 07:12:20 GMT&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attribute&#34;&gt;Content-Type&lt;/span&gt;: text/plain; charset=UTF-8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;p&gt;请求报文(自动发送保存着的 &lt;strong&gt;Cookie&lt;/strong&gt; 信息)&lt;/p&gt;
&lt;figure class=&#34;highlight http&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;GET&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;/image/&lt;/span&gt; HTTP/1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attribute&#34;&gt;Host&lt;/span&gt;: hackr.jp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attribute&#34;&gt;Cookie&lt;/span&gt;: sid=1342077140226724&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;





&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;&#34;&gt;&lt;a href=&#34;#&#34; class=&#34;headerlink&#34; title=&#34;&#34;&gt;&lt;/a&gt;&lt;/h1&gt;"> <!-- TODO: truncate -->
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="Amorki&#39;s" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    

<meta name="generator" content="Hexo 5.0.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        Amorki&#39;s
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
    
        <!-- GitHub -->
        <li>
            <a target="_blank" rel="noopener" href="https://github.com/amorkiki" class="github" title="Github"></a>
        </li>
        
            
                    
                        <!-- Facebook -->
                        <li>
                            <a target="_blank" rel="noopener" href="http://www.facebook.com/kiki.wu.92167789" class="facebook" title="Facebook"></a>
                        </li>
                        
                            
                                <!-- Twitter -->
                                <li>
                                    <a target="_blank" rel="noopener" href="http://www.twitter.com/BENICEXKiki" class="twitter" title="Twitter"></a>
                                </li>
                                
                                    
                                            
                                                    
                                                            
                                                                <!-- Instagram -->
                                                                <li>
                                                                    <a target="_blank" rel="noopener" href="http://www.instagram.com/wuuuuuujt" class="instagram" title="Instagram"></a>
                                                                </li>

                                                                
</ul>

<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="http://yoursite.com" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload -->
    <div id="content" class="inner">
        <article class="post">
	<h2 class="title">http_ReadNotes-01</h2>
    <div class="meta">
        <div class="date">Published on: <time datetime="2019-06-18T06:16:55.000Z" itemprop="datePublished">Jun 18, 2019</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/ReadNotes/">ReadNotes</a> <a href="/tags/http/">http</a>
</div>
    </div>
	<div class="entry-content"><blockquote>
<p>web开发中可能会用到用到 HTTP 协议的各方面知识 の 工作：</p>
<ul>
<li>编写网络爬虫phyton程序</li>
<li>分析抓包数据</li>
<li>实现 HTTP 服务器</li>
<li>提供网站 REST API</li>
<li>修改后端定制框架</li>
</ul>
</blockquote>
<hr>
<h1 id="I-web及网络基础"><a href="#I-web及网络基础" class="headerlink" title="I. web及网络基础"></a>I. web及网络基础</h1><p>==HTTP    (HyperText Transfer Protocol）   超文本传输协议== </p>
<h2 id="1-1-HTTP-协议访问-Web"><a href="#1-1-HTTP-协议访问-Web" class="headerlink" title="1.1  HTTP 协议访问 Web"></a><strong>1.1</strong>  <strong>HTTP</strong> 协议访问 Web</h2><ul>
<li>Web 是建立在 HTTP 协议上通信的。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9e5n5837j30if080gm2.jpg"></p>
<blockquote>
<p>根据指定的URL，web浏览器从web服务器获取相应资源（resource），然后呈现在web页面上，实现这种功能的web浏览器is—-<code>客户端(client)</code>。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9e9fsd4wj30hq05474o.jpg"></p>
<blockquote>
<p>完成这一系列事件，需要遵循一种规则约定—-超文本传输协议 is <code>HTTP</code> Hyper Text Transfer Protocol。</p>
</blockquote>
<h2 id="1-2-WWW-构建技术"><a href="#1-2-WWW-构建技术" class="headerlink" title="1.2 WWW 构建技术"></a>1.2 WWW 构建技术</h2><ol>
<li><code>HTML</code> ： 把 <code>SGML</code>(Standard Generalized Markup Language，标准通用标记语言)  作为页面的文本标 记语言的 <code>HTML</code>(HyperText Markup Language，超文本标记语言);</li>
<li><code>HTTP</code> ：作为文档传递协议的 HTTP。</li>
<li><code>URL</code> ：指定文档所在地址- URL(Uniform Resource Locator，统一资源定位符)。</li>
</ol>
<h2 id="1-3网络基础-TCP-IP"><a href="#1-3网络基础-TCP-IP" class="headerlink" title="1.3网络基础  TCP/IP"></a>1.3网络基础  TCP/IP</h2><blockquote>
<p>通常使用的 网络(包括互联网)是在  <code>TCP/IP 协议族</code>的基础上运作的。而 HTTP 属于它内部的一个子集。</p>
</blockquote>
<h3 id="1-3-1-TCP-IP-协议族"><a href="#1-3-1-TCP-IP-协议族" class="headerlink" title="1.3.1 TCP/IP 协议族"></a><strong>1.3.1</strong> <strong>TCP/IP</strong> 协议族</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9en3wyyzj30hz08jglz.jpg"></p>
<p>图:<strong>TCP/IP</strong> 是互联网相关的各类协议族的总称</p>
<h3 id="1-3-2-TCP-IP-的分层管理"><a href="#1-3-2-TCP-IP-的分层管理" class="headerlink" title="1.3.2 TCP/IP 的分层管理"></a><strong>1.3.2</strong> <strong>TCP/IP</strong> 的分层管理</h3><p>TCP/IP 协议族按  层次  分为 4 层:</p>
<ul>
<li><code>应用层</code>：<ul>
<li>决定了向用户<u>提供应用服务时的通信活动</u>；</li>
<li>TCP/IP 协议族内预存了各类通用的应用服务。<br>如：<code>FTP</code>(File Transfer Protocol，文件传输协议)、<br><code>DNS</code>(Domain Name System，域名系统) 服务</li>
<li>HTTP 协议也处于该层。</li>
</ul>
</li>
<li><code>传输层</code> ：<ul>
<li>对上层应用层，<u>提供处于网络连接中的两台计算机之间的数据传输</u>。</li>
<li>两个性质不同的协议:<br><code>TCP</code>(Transmission Control Protocol，传输控制协议)<br><code>UDP</code>(User Data Protocol，用户数据报协议)。</li>
</ul>
</li>
<li><code>网络层</code> ：<ul>
<li>处理在网络上流动的数据包，<u>数据包是网络传输的最小数据单位</u>。</li>
<li>规定了<u>通过怎样的路径</u>(所谓的传输路线)到达对方计算机，并<u>把数据包传送给对方</u>。</li>
<li>与对方计算机之间<u>通过多台计算机或网络设备进行传输时</u>，–<u>在众多的选项内选择一条传输路线</u>。</li>
</ul>
</li>
<li><code>数据链路层</code> ：（网络接口层）<ul>
<li>处理连接网络的硬件部分，包括–<br><u>控制操作系统</u>、<br><u>硬件的设备驱动</u><br><code>NIC</code>(Network Interface Card，网络适配器，即网卡)<br><u>光纤等物理可见部分</u>(还包括连接器等一切传输媒介)。</li>
<li>硬件上的范畴均在链路层的作用范围之内。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这样一来：要改变设计时，只需把变动的那层替换掉即可。</p>
<p>把各层之间的接口部分规划好之 后，每个层次内部的设计就能够自由改动了。</p>
</blockquote>
<h3 id="1-3-3-TCP-IP-通信传输流"><a href="#1-3-3-TCP-IP-通信传输流" class="headerlink" title="1.3.3 TCP/IP 通信传输流"></a><strong>1.3.3</strong> <strong>TCP/IP</strong> 通信传输流</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9f2itcrej30i90e0wf5.jpg"></p>
<blockquote>
<p>发送端从应用层往下走，接收端则往应用层往上走。</p>
</blockquote>
<p>发出HTTP请求 </p>
<p>​    👇</p>
<p>TCP协议把HTTP 请求报文进行分割 ，打上标记序号、端口号</p>
<p>​    👇</p>
<p>IP 协议增加MAC 地址(作为<u>通信目的地</u>的 )后转发给链路层</p>
<p>​    👇</p>
<p>这样一来，发往网络的通信请求就准备齐全了。</p>
<p>​    👇</p>
<p>接收端的服务器在链路层接收到数据，按序往上层发送</p>
<p>​    👇</p>
<p>当传输到应用层，才算真正接收到由客端发送过来的 HTTP 请求👩</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9fbm9tolj30i80fvdh9.jpg"></p>
<blockquote>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个==该层所属的首部信息==。</p>
<p>接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<p>这种==把数据信息包装起来==的做法称为<code>封装</code>(encapsulate)。</p>
</blockquote>
<h2 id="1-4-IP、TCP-和-DNS-—与-HTTP-关系密切"><a href="#1-4-IP、TCP-和-DNS-—与-HTTP-关系密切" class="headerlink" title="1.4  IP、TCP 和 DNS —与 HTTP 关系密切"></a><strong>1.4</strong>  IP、TCP 和 DNS —与 <strong>HTTP</strong> 关系密切</h2><h3 id="1-4-1-负责传输的-IP-协议"><a href="#1-4-1-负责传输的-IP-协议" class="headerlink" title="1.4.1 负责传输的 IP 协议"></a><strong>1.4.1</strong> 负责传输的 <strong>IP</strong> 协议</h3><ul>
<li><p><code>IP 地址</code>  ：指明了节点被分配到的地址</p>
</li>
<li><p><code>MAC 地址</code>(Media Access Control Address) ：网卡所属的固定地址</p>
</li>
<li><p>IP 地址可以和 MAC 地址进行配对；IP 地址可变换，MAC 地址基本上不会更改。</p>
</li>
<li><p>IP 间的通信依赖 MAC 地址</p>
</li>
</ul>
<p>在网络上，通信的双方在同一局域网 (LAN)内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。</p>
<p>而在进行<u>中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标</u>。</p>
<p>这时，会采用 <code>ARP 协议</code>(Address Resolution Protocol)。</p>
<ul>
<li><p><code>ARP</code> 是用来  **<u>解析地址</u>**的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。</p>
</li>
<li><p><code>路由选择(routing)</code> ：在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。这种机制称为路由选择(routing)</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9gfsicbwj30hh0g075q.jpg"></p>
<h3 id="1-4-2-确保可靠性的-TCP-协议"><a href="#1-4-2-确保可靠性的-TCP-协议" class="headerlink" title="1.4.2 确保可靠性的 TCP 协议"></a><strong>1.4.2</strong> 确保可靠性的 <strong>TCP</strong> 协议</h3><blockquote>
<p>TCP 位于传输层，提供可靠的字节流服务。</p>
</blockquote>
<ul>
<li><p><code>字节流服务</code>— 将大块数据分割成以报文段(segment)为单位的数据包进行管理。</p>
</li>
<li><p>TCP 协议为 了更容易传送大数据才把数据分割；</p>
</li>
<li><p>TCP 协议能够确认数据最终是否送达到对方： <code>三次握手(three-way handshaking)策略</code></p>
<ul>
<li>数据包送出去后，TCP会向对方确认是否成功送达；</li>
<li>握手过程使用：<ul>
<li>TCP 的标志(flag) </li>
<li>SYN(synchronize) </li>
<li>ACK(acknowledgement)。</li>
</ul>
</li>
</ul>
<p>SNY ➡️</p>
<p>​        ⬅️ SNY/ACK</p>
<p>ACK➡️   </p>
<p>​                    </p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9glwue5cj30hg09p3za.jpg"></p>
<h2 id="1-5-负责域名解析的-DNS-服务"><a href="#1-5-负责域名解析的-DNS-服务" class="headerlink" title="1.5 负责域名解析的 DNS 服务"></a>1.5 负责域名解析的 <strong>DNS</strong> 服务</h2><ul>
<li><p><code>DNS</code>(Domain Name System)提供<strong>域名</strong>到 IP 地址之间的<strong>解析服务</strong>。</p>
</li>
<li><p><strong><u>计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。</u></strong></p>
</li>
<li><p>用户通常使用<code>主机名</code>或<code>域名</code>来访问对方的计算机</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9h2hmrbjj30he0bbaay.jpg"></p>
<h2 id="1-6-各种协议与-HTTP-协议的关系"><a href="#1-6-各种协议与-HTTP-协议的关系" class="headerlink" title="1.6 各种协议与 HTTP 协议的关系"></a><strong>1.6</strong> 各种协议与 <strong>HTTP</strong> 协议的关系</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9h85ouxyj30ft0mswgr.jpg"></p>
<h2 id="1-7-URI-和-URL"><a href="#1-7-URI-和-URL" class="headerlink" title="1.7 URI 和 URL"></a><strong>1.7</strong> <strong>URI</strong> 和 <strong>URL</strong></h2><p><code>URI</code>  Uniform Resource Identifier   统一资源标识符</p>
<ul>
<li>由某个协议方案表示的资源的定位标识符。</li>
<li>协议方案是指  访问资源所使用的协议类型名称；采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、mailto、telnet、file 等；</li>
<li><code>URI</code> 用字符串标识某一互联网资源，而 <code>URL</code> 表示资源的地点(互联 网上所处的位置)。</li>
</ul>
<h3 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a><strong>URI</strong> 格式</h3><ul>
<li>绝对 URI </li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9icxnnjvj30g703twer.jpg"></p>
<blockquote>
<p>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。</p>
<p>不区分字母大小写，最后附一个冒号(:)。</p>
<p>也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。</p>
</blockquote>
<h5 id="📟-登录信息-认证"><a href="#📟-登录信息-认证" class="headerlink" title="📟 登录信息(认证)"></a>📟 登录信息(认证)</h5><p>指定用户名和密码作为从服务器端获取资源时必要的登录信息(身份认证)。此项是可选项。</p>
<h5 id="✉️-服务器地址"><a href="#✉️-服务器地址" class="headerlink" title="✉️  服务器地址"></a>✉️  服务器地址</h5><p>使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 <code>DNS</code> 可解析的名称，或是 192.168.1.1 这类 <code>IPv4</code> 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 <code>IPv6</code> 地址名。</p>
<h5 id="🕰-服务器端口号"><a href="#🕰-服务器端口号" class="headerlink" title="🕰 服务器端口号"></a>🕰 服务器端口号</h5><p>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动 使用默认端口号。</p>
<h5 id="📑-带层次的文件路径"><a href="#📑-带层次的文件路径" class="headerlink" title="📑 带层次的文件路径"></a>📑 带层次的文件路径</h5><p>指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</p>
<h5 id="🔑-查询字符串"><a href="#🔑-查询字符串" class="headerlink" title="🔑 查询字符串"></a>🔑 查询字符串</h5><p>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参 数。此项可选。</p>
<h5 id="🔫-片段标识符"><a href="#🔫-片段标识符" class="headerlink" title="🔫 片段标识符"></a>🔫 片段标识符</h5><p>使用片段标识符通常可标记出已获取资源中的子资源(文档内的某个位置)。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。</p>
<blockquote>
<p>一些用来制定 HTTP 协议技术标准的文档，它们被称为<code>RFC</code>(Request for Comments，征求修正意见书)。</p>
<p>并不是所有的应用程序都符合 RFC</p>
<p>RFC 是 互联网的设计文档，要是不按照 RFC 标准执行，就有可能导致无法通信的状况。</p>
<p>基本 上客户端和服务器端都会以 RFC 为标准来实现 HTTP 协议。</p>
</blockquote>
<hr>
<h1 id="II-简单的-HTTP-协议"><a href="#II-简单的-HTTP-协议" class="headerlink" title="II.简单的 HTTP 协议"></a>II.简单的 HTTP 协议</h1><h2 id="2-1-HTTP-协议作用"><a href="#2-1-HTTP-协议作用" class="headerlink" title="2.1 HTTP 协议作用"></a>2.1 <strong>HTTP</strong> 协议作用</h2><p><strong>HTTP</strong> 协议用于客户端和服务器端之间的<code>通信</code></p>
<p>请求访问文本或图像等资源的一端称为<code>客户端</code>，而提供资源响应的一 端称为<code>服务器端</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfomjb1s01j30jx07zt9e.jpg"></p>
<p>两台计算机作为客户端和服务器端的<u>角色有可能会互换</u>。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器端。</p>
<h2 id="2-2-How达成通信"><a href="#2-2-How达成通信" class="headerlink" title="2.2 How达成通信"></a><strong>2.2</strong> How达成通信</h2><p>通过<code>请求和响应的交换</code>达成通信</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfommtf5i8j30jk074q3k.jpg"></p>
<p>肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfomnk9uoij30k90acgmd.jpg"></p>
<p><strong>客户端发送给某个 HTTP 服务器端的请求报文中</strong>：</p>
<p><code>GET</code>—— 请求访问服务器的类型，称为方法 (method)。</p>
<p><code>字符串 /index.htm</code> ——-请求访问的资源对象， 也叫做请求 URI(request-URI)。</p>
<p> <code>HTTP/1.1</code>—— HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。</p>
<p>综合来看，这段请求内容的意思是:<u>请求访问某台 HTTP 服务器上的 /index.htm 页面资源。</u></p>
<p><code>请求报文</code>是由==请求方法==、==请求 URI==、==协议版本==、==可选的请求首部字段== 和内==容实体==构成的。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfomrgipocj30k60azgm8.jpg"></p>
<p><strong>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回：</strong></p>
<p> <code>HTTP/1.1</code> 表示服务器对应的 HTTP 版本。</p>
<p><code>200 OK</code> 表示请求的处理结果的状态码(status code)和原因短语(reason-phrase)。</p>
<p>下一行显示了创建响应的日期时间，是首部字段(header field)内的一个属性。</p>
<p>接着以一空行分隔，之后的内容称为<code>资源实体的主体</code>(entity body)。</p>
<p><code>响应报文</code>基本上由==协议版本==、==状态码(表示请求成功或失败的数字代码)==、==用以解释状态码的原因短语==、==可选的响应首部字段==以及==实体主体==构成。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfomutu23fj30k20awaal.jpg"></p>
<h2 id="2-3-HTTP-是不保存状态的协议"><a href="#2-3-HTTP-是不保存状态的协议" class="headerlink" title="2.3 HTTP 是不保存状态的协议"></a><strong>2.3</strong> <strong>HTTP</strong> 是不保存状态的协议</h2><p>HTTP 是一种不保存状态，即<code>无状态(stateless)协议</code>。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。</p>
<p>这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设 计成如此简单的。</p>
<p>HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 <code>Cookie 技术</code>。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>
<h2 id="2-4-请求-URI-定位资源"><a href="#2-4-请求-URI-定位资源" class="headerlink" title="2.4 请求 URI 定位资源"></a><strong>2.4</strong> 请求 <strong>URI</strong> 定位资源</h2><p>HTTP 协议使用 <strong>URI 定位互联网上的资源</strong>。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfomywnmktj30js0em0u5.jpg"></p>
<p>当客户端请求访问资源而发送请求时，<strong>URI 需要将作为请求报文中的请求 URI 包含在内</strong>。</p>
<p><strong>指定请求 URI 的方式</strong>有很多。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfomzmqy4sj30jn0a5mxp.jpg"></p>
<p>如果不是访问特定资源而是对服务器本身发起请求，可以 用一个 * 来代替请求 URI。</p>
<p>下面这个例子是查询 HTTP 服务器端支持 的 HTTP 方法种类。</p>
<p>OPTIONS * HTTP/1.1</p>
<h2 id="2-5-告知服务器意图的-HTTP-方法"><a href="#2-5-告知服务器意图的-HTTP-方法" class="headerlink" title="2.5 告知服务器意图的 HTTP 方法"></a><strong>2.5</strong> 告知服务器意图的 <strong>HTTP</strong> 方法</h2><h3 id="GET-获取资源"><a href="#GET-获取资源" class="headerlink" title="GET :获取资源"></a><strong>GET</strong> :获取资源</h3><ul>
<li>==请求访问已被 URI 识别的资源==</li>
<li>指定的资源经服务器端解析后返回响应内容。</li>
<li>如果请求的资源是文本，那就保持原样返回;如果是像 CGI(Common Gateway Interface，通用网关接 口)那样的程序，则返回经过执行后的输出结果。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfon42wnpfj30g7060mxc.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfon4f24taj30lc09pq3m.jpg"></p>
<h3 id="POST-传输实体主体"><a href="#POST-传输实体主体" class="headerlink" title="POST:传输实体主体"></a><strong>POST</strong>:传输实体主体</h3><ul>
<li>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。</li>
<li>虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfon6hk66ej30hd061dg0.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfon6pxttjj30hs04omxg.jpg"></p>
<h3 id="PUT-传输文件"><a href="#PUT-传输文件" class="headerlink" title="PUT:传输文件"></a><strong>PUT</strong>:传输文件</h3><ul>
<li>就像 FTP 协议的文件上传一样，要求<u>在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置</u>。</li>
<li>鉴于 HTTP/1.1 的 PUT 方法自身<u>不带验证机制</u>，任何人都可以上传文件 , 存在安全性问题，因此<u>一般的 Web 网站不使用该方法。</u></li>
<li>若配合 Web 应用程序的验证机制，或架构设计采用 REST(REpresentational State Transfer，表征状态转移)标准的同类 Web 网站，就可能会开放使用 PUT 方法。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfon8qkhtdj30ki0cwt9w.jpg"></p>
<h3 id="HEAD-获得报文首部"><a href="#HEAD-获得报文首部" class="headerlink" title="HEAD:获得报文首部"></a><strong>HEAD</strong>:获得报文首部</h3><ul>
<li>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于<u>确认 URI 的有效性</u>及<u>资源更新的日期时间</u>等。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfon9zhpr5j30is0893yv.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfona6xjqmj30i804igls.jpg"></p>
<h3 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE:删除文件"></a><strong>DELETE</strong>:删除文件</h3><ul>
<li><p>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法<u>按 请求 URI 删除指定的资源。</u></p>
</li>
<li><p>但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样<u>不带验证机制</u>，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonbcmqytj30jy09naaw.jpg"></p>
<h3 id="OPTIONS-询问支持的方法"><a href="#OPTIONS-询问支持的方法" class="headerlink" title="OPTIONS:询问支持的方法"></a><strong>OPTIONS</strong>:询问支持的方法</h3><ul>
<li><u>查询针对请求 URI 指定的资源支持的方法</u>。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonbvvjfej30jk070gly.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonc8192qj30iv05qaad.jpg"></p>
<h3 id="TRACE-追踪路径"><a href="#TRACE-追踪路径" class="headerlink" title="TRACE:追踪路径"></a><strong>TRACE</strong>:追踪路径</h3><ul>
<li><p><u>让 Web 服务器端将之前的请求通信环回给客户端的方法。</u></p>
</li>
<li><p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。</p>
</li>
<li><p>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。</p>
<p>但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST(Cross-Site Tracing，跨站追踪)攻击，通常就更不会用到了。</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonecee5bj30j60cvmyl.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoneu42hcj30ip041t8r.jpg"></p>
<h3 id="CONNECT-要求用隧道协议连接代理"><a href="#CONNECT-要求用隧道协议连接代理" class="headerlink" title="CONNECT:要求用隧道协议连接代理"></a><strong>CONNECT</strong>:要求用隧道协议连接代理</h3><ul>
<li><p>要求<u>在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。</u></p>
</li>
<li><p>主要使用 SSL(Secure Sockets Layer，安全套接 层)和 TLS(Transport Layer Security，传输层安全)协议把通信内容加密后经网络隧道传输。</p>
</li>
<li><p>CONNECT 方法的格式如下所示。 </p>
<ul>
<li>CONNECT 代理服务器名:端口号 HTTP版本</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfong1l3d3j30jc0bi3zk.jpg"></p>
<h2 id="2-6-使用方法下达命令"><a href="#2-6-使用方法下达命令" class="headerlink" title="2.6 使用方法下达命令"></a><strong>2.6</strong> 使用方法下达命令</h2><ul>
<li><strong>向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。</strong></li>
<li>方法的作用在于，<strong>可以指定请求的资源按期望产生某种行为</strong>。</li>
<li>方法中 有 <code>GET</code>、<code>POST</code> 和 <code>HEAD</code> 等。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonh7ww7ij30jq08vwf8.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonhxn0q6j30jt0fhtah.jpg"></p>
<h2 id="2-7-持久连接节省通信量"><a href="#2-7-持久连接节省通信量" class="headerlink" title="2.7 持久连接节省通信量"></a><strong>2.7</strong> 持久连接节省通信量</h2><h3 id="2-7-1-持久连接"><a href="#2-7-1-持久连接" class="headerlink" title="2.7.1 持久连接"></a><strong>2.7.1</strong> 持久连接</h3><p>持久连接(HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse)</p>
<p><strong>特点</strong>： 只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonjpakaaj30jr0h90ud.jpg"></p>
<p><strong>好处</strong>：</p>
<ul>
<li>减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。</li>
<li>使 HTTP 请求和响应能够更早地结束，Web 页面的显示速度提高。</li>
</ul>
<h3 id="2-7-2-管线化"><a href="#2-7-2-管线化" class="headerlink" title="2.7.2 管线化"></a><strong>2.7.2</strong> 管线化</h3><ul>
<li>久连接使得多数请求以管线化(pipelining)方式发送成为可能。</li>
<li>管线化技术使得 不用等待响应亦可直接发送下一个请求。</li>
<li>同时并行发送多个请求，而不需要一个接一个地等待响应。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonn8n2qrj30jr09p752.jpg"></p>
<h3 id="2-8-使用-Cookie-的状态管理"><a href="#2-8-使用-Cookie-的状态管理" class="headerlink" title="2.8 使用 Cookie 的状态管理"></a><strong>2.8</strong> 使用 <strong>Cookie</strong> 的状态管理</h3><p>HTTP 是无状态协议，无法根据之前的状态进行本次的请求处理。不保存状态，减少服务器的 CPU 及内存资源的消耗。</p>
<p><code>Cookie 技术</code>通过==在请求和响应报文中写入 Cookie 信息来控制客户端的状态==。</p>
<ul>
<li>根据从服务器端发送的响应报文内的 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。</li>
<li>当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</li>
<li>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonvunolbj30j90ah0te.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfonwajvvej30j7093wf1.jpg"></p>
<p><strong>HTTP 请求报文和响应报文的内容:</strong></p>
<ol>
<li><p>请求报文(没有 <strong>Cookie</strong> 信息的状态)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/reader/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: hackr.jp </span><br><span class="line">*首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>响应报文(服务器端生成 <strong>Cookie</strong> 信息)</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache</span><br><span class="line">&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain; charset=UTF-8</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>请求报文(自动发送保存着的 <strong>Cookie</strong> 信息)</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/image/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: hackr.jp</span><br><span class="line"><span class="attribute">Cookie</span>: sid=1342077140226724</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1></div>

<div class="meta">
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>




    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2020

    JTW
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a target="_blank" rel="noopener" href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a target="_blank" rel="noopener" href="http://github.com/panks/fabric">fabric</a> by <a target="_blank" rel="noopener" href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>

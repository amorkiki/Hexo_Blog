---
title: 后台接口构建-01
date: 2019-3-01 00:24:37
tags: [nodejs, myProject]
top_img: false
categories: project-share
aside: true
indexing: true
cover: https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpf0kcfj30ea05uaa8.jpg
---

写在前面的话~~~

每年的读书计划都不了了之....买了新书忘了旧书说的就是我 🤦‍♀️🤦‍♀️
so...想建一个私人图书馆小平台，记录购买的书和每本书的阅读进度

今天先写点学习の后台接口搭建步骤和 bug 解决（bug 一卡卡三年我是什么样的心情...)
👨‍💻‍

构建接口文档：Node+express+jwt(实现 token)

> 接口文档内容：Nodejs
>
> - 准备工作：
>   - 搭建服务器
>   - 链接 MongoDB
>   - 搭建路由和数据模型
> - 注册登录接口
>   - 注册接口数据存储
>   - 全球公认头像
>   - 登录接口数据存储
>   - JWT 实现 token

---

Node-app 文件夹下：npm init 初始化项目

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpf0kcfj30ea05uaa8.jpg)

↓

在 VScode 里打开项目，快捷键 ctr+`在 vscode 里打开终端，在当前 node-app 文件夹创建入口文件 touch server.js

↓

安装 express 包 npm install express

↓

在入口文件开始搭建服务器:

- 引入 express 框架 const express = **require**('express');

- 实例化一个 app, const app = **express**();

- 给予一个端口号 const port = process.env.PORT **||** 5000; (本地端口号是 5000)

- 监听一下 app, 并打印处相应端口号

  ```js
  app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
  });
  ```

↓

在终端 node server.js 就可以运行该项目了，但此时还没有设置任何路由，暂时还无法访问哦~~

↓

在实例化的 app 下设置个路由：

```js
app.get("/", (req, res) => {
  res.send("hello");
});
```

↓

用 nodemon server.js 启动服务器~~

↓

在 package.json 里的 scripts 里更改自定义命令

- npm run start : 项目最后上线时
- npm run server：项目还在开发时，实时监测改变

```json
  "scripts": {
    "start": "node server.js",
    "server": "nodemon server.js"
  },
```

↓

链接 MongoDB 数据库:

- 登录 mongodb 线上数据库，新建数据库
- 用 mongoDB Compass 方式链接 mongodb+srv://amork:jing985464@cluster0.jiogy.mongodb.net/test

↓

在项目中安装 mongoose 包 npm install mongoose

在 server.js 入口文件中引入 const mongoose = **require**("mongoose");

这样我们就可以直接使用 mongoose 对象连接数据库

↓

我们新建一个专用文件夹 config，新建文件 keys.js,

在该文件夹下，exports 模块，写入 mongoURI：拷贝的地址

```js
module.exports = {
  mongoURI: "mongodb+srv://amork:jing985464@cluster0.jiogy.mongodb.net/test",
};
```

在入口文件引入模块：

```js
const db = require("./config/keys").mongoURI;
```

这样做的好处： 可以手动更改数据库连接的地址 mongoURI，如果想用本地数据库

连接数据库---mongoose.connect

```js
//connect to mongodb
mongoose
  .connect(db)
  .then(() => console.log("mongoDB connected"))
  .catch((error) => console.log(error));
```

此时 terminal 中若返回 mongoDB connected，则表示连接成功

↓

小问题：终端中还会出现如下警告：
![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpgf84zj30q404tt9i.jpg)

解决： 拷贝{ useNewUrlParser: **true**, useUnifiedTopology: **true** } 粘贴到 connect(db, 这里)

此时发现没有报错啦~~

↓

下面就开始搭建自己的接口啦~

创建文件夹 routers -->APIs --> 新建文件 users.js 用来用户登录和注册

- 同理引入 express，再实例化一个 router，并创建路由链接，最后别忘了暴露出去哦~

  ```js
  router.get("/test", (req, res) => {
    res.json({ msg: "login works" });
  });
  //这里response一个json对象，包含msg,表示当访问localhost:5000/test时，会返回msg里的话

  module.exports = router;
  ```

- 在入口文件引入 user 路由，并使用它

  ```js
  //引入user.js
  const users = require("./routers/api/users");

  // 使用routers
  app.use("/api/users", users);
  ```

- 在浏览器中输入 localhost：5000/api/users/test 检查路由是否设置成功

  当然也可用第三方工具 postman 测试接口
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpfhodmj30ca02sjr9.jpg)

↓

创建模型存储对应的数据：

- 创建文件夹 models --> 创建 User.js 文件，引入 mongoose（要将数据存储在其中），再实例化一个 Schema，创建集合，向集合中插入数据

  ```js
  const mongoose = require("mongoose");
  const Schema = mongoose.Schema;

  // Create Schema
  const UserSchema = new Schema({});
  ```

- 创建集合规则：登录和注册时，需要什么，就在 Schema 对象中写什么(暂时先马马虎虎写一下，最后再修改)

  ```js
  // Create Schema
  const UserSchema = new Schema({
    name: {
      type: String,
      required: true,
    },
    email: {
      type: String,
      required: true,
    },
    password: {
      type: String,
      required: true,
    },
    avatar: {
      type: String,
    },
    date: {
      type: Date,
      default: Date.now,
    },
  });
  ```

- 最后使用使用规则创建集合，并暴露出去

  model 里的参数：（集合名称，集合规则）

  ```js
  module.exports = User = mongoose.model("users", UserSchema);
  ```

↓

搭建用户登录页面的 register 接口：

- 因为注册的时候一定会传递一些对应信息，所以要改用 post 请求

- 安装第三方模块 bodyParser -- npm install body-parser

- 在入口文件中引入 body-parser：const bodyParser = **require**("body-parser");

- // _使用 body-parser 中间件_

  app.**use**(bodyParser.**urlencoded**({ extended: **false** }));

  app.**use**(bodyParser.**json**());

- 在路由 user.js 中引入 User 模块，添加 post 请求

  ```js
  // $route GET api/users/register
  // @desc  返回请求的json数据
  // @access public
  router.post("/register", (req, res) => {
    // console.log(req.body);
    //查询数据库中是否拥有邮箱
    User.findOne({ email: req.body.email }).then((user) => {
      if (user) {
        return res.status(400).json({ email: "邮箱已被注册" });
      } else {
        const newUser = new User({
          name: req.body.name,
          email: req.body.email,
          avatar: avatar,
          password: req.body.password,
        });
      }
    });
  });
  ```

- 如果要给密码，需要安装 bcrypt----npm install bcrypt，并在当前文件引入

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpdbj59j30v90acdhk.jpg)

  ```js
  // 给密码加密
  bcrypt.genSalt(10, function (err, salt) {
    bcrypt.hash(newUser.password, salt, (err, hash) => {
      if (err) throw err; // 如果出错了 直接抛出错误
      newUser.password = hash; // 密码变成hash值
      newUser
        .save() //调用save存储数据
        .then((user) => res.json(user)) //并且但会json对象
        .catch((err) => console.log(err)); //如果错误则打印错误
    });
  });
  ```

- 测试下是否能讲当前数据存到数据库中
  出现报错 ：

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpem9jwj30no03smxs.jpg)

  解决：可能是无法识别 ES6 语法，把箭头函数改为普通函数, thow err 改为 return err

  ```js
  bcrypt.hash(newUser.password, 10, function (err, hash) {
    if (err) {
      return err;
    }
    newUser.password = hash;
    newUser
      .save()
      .then((user) => res.json(user))
      .catch((err) => console.log(err));
  });
  ```

  运行后可在 postman 中拿到加密过后的数据
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpe2o0wj30iy04n0t4.jpg)

  完整的请求 👇
  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwf820ayxj30ds069wex.jpg" style="zoom:150%;" />

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwf8e38r3j30bi065jrq.jpg" style="zoom:150%;" />

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwf920x46j30vy02dq32.jpg" style="zoom:200%;" />

- 来到 MongoDB Compass 的控制面板里，查看数据库中新增了 test 目录，里面保存了 users，数据已经传上来啦~

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpfyvznj30rk0dmabj.jpg)

↓

关于头像的问题 avartar---使用第三方 gravatar

- npm install gravatar

- 在需要使用的地方（users.js)中引入，const gravatar = **require**("gravatar");

- 在 newUser 之前，定义 avatar 先
  (官网 copy)：

  - url 代表 gravatar 下的一个方法，接受 2 个参数，第一个是用户邮箱，第二个是一些 options，
    - s: size
    - r:rating （可能是一种图片的参数）
    - d:default

  ```js
  var url = gravatar.url("emerleite@gmail.com", {
    s: "200",
    r: "pg",
    d: "404",
  });
  ```

  - 对代码稍作改动

    ```js
    const avatar = gravatar.url("req.body.email", {
      s: "200",
      r: "pg",
      d: "mm",
    });
    ```

- 在 postman 中用一个新邮箱测试一下，此时已经拿到了 avatar 的地址
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfzpzvmkj30jj050dgg.jpg)

  这个地址显示的图像是介个样子 👉<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwg23njtcj305p05smwy.jpg" style="zoom:80%;" />

  如果用真实的，设置过 avatar 头像的邮箱来做 avatar 请求，则会拿到你真实的头像哦~

↓

搭建登录接口：

- 继续在 users.js 里添加登录接口，此时要求返回 token， jwt passport

- 拿到 email 和 password 之后与数据库进行匹配， 密码匹配这里用到了 bcrypt 里面的 compare
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgktc25vj30o203n74q.jpg)

  ```js
  bcrypt.compare(password, user.password).then((isMatch) => {
    if (isMatch) {
      res.json({ msg: "success" });
    } else {
      return res.status(400).json({ password: "密码错误" });
    }
  });
  ```

  先不做 token，在 res.json 里直接返回 msg, 看下能否在邮箱正确，错误，密码正确，错误的情况下能否正确返回：

  正确情况下 👇：
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgqxb9xzj30fu0b4dg9.jpg)
  邮箱错误 👇：
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgsmr166j30e509wt91.jpg)

  密码错误 👇：

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgt8vdvsj30du0a6glx.jpg)

- 返回 token：

  - npm install jsonwebtoken

  - 引入 jsonwebtoken，起名 jwt

  - 调用 jwt.sign 方法，传递相应规则： jwt.**sign**("规则", "加密名字", "过期时间", "箭头函数");
    加密名字 secret 可以在 keys 里面提前定义好: secretOrKey: "secret",
    ↓

    ```js
    bcrypt.compare(password, user.password).then((isMatch) => {
      if (isMatch) {
        const rule = { id: user.id, name: user.name };
        jwt.sign(rule, keys.secretOrKey, { expiresIn: 3600 }, (err, token) => {
          if (err) throw err;
          res.json({
            success: true,
            token: "Bearer " + token, //Bearer后有一个空格
          });
        });
      } else {
        return res.status(400).json({ password: "密码错误" });
      }
    });
    ```

  - 调试下~ ok~拿到 token

    ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwi4bgprmj30ok0c3dh4.jpg)

↓

验证 token：

- ```js
  // $route GET api/users/current
  // @desc  return current user
  // @access private
  router.get("/current", "验证token", (req, res) => {
    res.json({ msg: "success" });
  });
  ```

- 用到 passport 来验证 token

  - npm install passport passport-jwt

  - 在入口文件中先引入 passport， 并初始化 passport：app.use(passport.initialize())

    ```js
    // passport 初始化
    app.use(passport.initialize());
    // 引入passport.js代码，同时把上面const的passport传递，这样直接把代码写在passport.js里
    require("./config/passport")(passport);
    ```

  - 在另外单独文件夹中配置 passport

    - config-->新建 passport.js , 在 passport-jwt 官网下引入相关配置

  ```js
  const JwtStrategy = require("passport-jwt").Strategy,
    ExtractJwt = require("passport-jwt").ExtractJwt;
  const mongoose = require("mongoose");
  const User = mongoose.model("users");

  const keys = require("../config/keys");

  const opts = {};
  opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();
  opts.secretOrKey = keys.secretOrKey;

  module.exports = (passport) => {};
  ```

  ↓

  ```js
  module.exports = (passport) => {
    passport.use(
      new JwtStrategy(opts, (jwt_payload, done) => {
        console.log(jwt_payload);
      })
    );
  };
  ```

  ↓

  配置完成，来到 users.js 引入 passport 后，添加接口

  ```js
  // $route GET api/users/current
  // @desc  return current user
  // @access private
  router.get(
    "/current",
    passport.authenticate("jwt", { session: false }),
    (req, res) => {
      res.json({ msg: "success" });
    }
  );
  ```

  将刚拿到的 token，放到 current 接口的 header 中，测试一下，终端会返回，因为在 passport.use 里我们写了 console.log~ 👆
  👇
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwi70e0u2j30ae03k749.jpg)

  ↓

  既然拿到了数据，就可以通过查询后返回用户信息

  ```js
  module.exports = (passport) => {
    passport.use(
      new JwtStrategy(opts, (jwt_payload, done) => {
        console.log(jwt_payload);
        User.findById(jwt_payload.id)
          .then((user) => {
            if (user) {
              return DOMError(null, user);
            }
            return done(null, false);
          })
          .catch((err) => console.log(err));
      })
    );
  };
  ```

  ↓

  调整下返回的代码，只返回 user 对象中的 id,name, email

  ```js
  // $route GET api/users/current
  // @desc  return current user
  // @access private
  router.get(
    "/current",
    passport.authenticate("jwt", { session: false }),
    (req, res) => {
      res.json({
        id: req.user.id,
        name: req.user.name,
        email: req.user.email,
      });
    }
  );
  ```

↓

增加身份字段，添加权限（项目中用不到权限管理的可以忽略这一步）

- 在 User.js 里添加 identity 字段
- 在 users.js 接口文件中的 newUser 中补上 identity
- 在登录接口位置，在 isMath 规则处和 res.json 处添加 identity

↓

login、register、current 三个接口测试通过
![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjusnjrvj30l00f9q4l.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjv4a1roj30na0eegnj.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjwn1ssbj30kg04amxd.jpg)

↓
明天继续~ 晚安 🐶

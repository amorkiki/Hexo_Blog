---
title: 后台接口构建-01
date: 2020-08-20 00:24:37
tags: [nodejs,myProject]
---
写在前面的话~~~

每年的读书计划都不了了之....买了新书忘了旧书说的就是我🤦‍♀️🤦‍♀️
so...想建一个私人图书馆小平台，记录购买的书和每本书的阅读进度

今天先写点学习の后台接口搭建步骤和bug解决（bug一卡卡三年我是什么样的心情...)
👨‍💻‍

构建接口文档：Node+express+jwt(实现token)

> 接口文档内容：Nodejs
>
> - 准备工作： 
>   - 搭建服务器
>   - 链接MongoDB
>   - 搭建路由和数据模型
> - 注册登录接口
>   - 注册接口数据存储
>   - 全球公认头像
>   - 登录接口数据存储
>   - JWT实现token
----------------------------------------------
Node-app文件夹下：npm init  初始化项目

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpf0kcfj30ea05uaa8.jpg)



↓

在VScode里打开项目，快捷键ctr+`在vscode里打开终端，在当前node-app文件夹创建入口文件touch server.js

↓

安装express包  npm install express

↓

在入口文件开始搭建服务器:  

- 引入express框架   const express = **require**('express');

- 实例化一个app,    const app = **express**();

- 给予一个端口号  const port = process.env.PORT **||** 5000;   (本地端口号是5000)

- 监听一下app, 并打印处相应端口号

  ```js
  app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
  })
  ```

↓

在终端 node server.js 就可以运行该项目了，但此时还没有设置任何路由，暂时还无法访问哦~~

↓

在实例化的app下设置个路由：

```js
app.get("/", (req, res) => {
  res.send("hello");
});
```

↓

用nodemon server.js 启动服务器~~

↓

在package.json里的scripts里更改自定义命令

- npm run start  : 项目最后上线时
- npm run server：项目还在开发时，实时监测改变

```json
  "scripts": {
    "start": "node server.js",
    "server": "nodemon server.js"
  },
```

↓

链接MongoDB数据库:

- 登录mongodb线上数据库，新建数据库
- 用mongoDB Compass 方式链接 mongodb+srv://amork:jing985464@cluster0.jiogy.mongodb.net/test

↓

在项目中安装mongoose包  npm install mongoose

在server.js入口文件中引入const mongoose = **require**("mongoose");

这样我们就可以直接使用mongoose对象连接数据库

↓

我们新建一个专用文件夹config，新建文件keys.js,

在该文件夹下，exports模块，写入mongoURI：拷贝的地址

```js
module.exports = {
  mongoURI: "mongodb+srv://amork:jing985464@cluster0.jiogy.mongodb.net/test",
};
```

在入口文件引入模块：

```js
const db = require("./config/keys").mongoURI;
```

这样做的好处： 可以手动更改数据库连接的地址mongoURI，如果想用本地数据库

连接数据库---mongoose.connect

```js
//connect to mongodb
mongoose
  .connect(db)
  .then(() => console.log("mongoDB connected"))
  .catch((error) => console.log(error));
```

此时terminal中若返回mongoDB connected，则表示连接成功

↓

小问题：终端中还会出现如下警告：
![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpgf84zj30q404tt9i.jpg)

解决： 拷贝{ useNewUrlParser: **true**, useUnifiedTopology: **true** } 粘贴到 connect(db, 这里)

此时发现没有报错啦~~

↓

下面就开始搭建自己的接口啦~

创建文件夹routers -->APIs --> 新建文件users.js 用来用户登录和注册

- 同理引入express，再实例化一个router，并创建路由链接，最后别忘了暴露出去哦~

  ```js
  router.get("/test", (req, res) => {
    res.json({msg:"login works"})
  })
  //这里response一个json对象，包含msg,表示当访问localhost:5000/test时，会返回msg里的话
  
  module.exports = router;
  ```

- 在入口文件引入user路由，并使用它

  ```js
  //引入user.js
  const users = require("./routers/api/users");
  
  // 使用routers
  app.use("/api/users", users);
  ```

- 在浏览器中输入localhost：5000/api/users/test 检查路由是否设置成功

  当然也可用第三方工具postman测试接口
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpfhodmj30ca02sjr9.jpg)

↓

创建模型存储对应的数据：

- 创建文件夹models --> 创建User.js文件，引入mongoose（要将数据存储在其中），再实例化一个Schema，创建集合，向集合中插入数据

  ```js
  const mongoose = require("mongoose");
  const Schema = mongoose.Schema;
  
  // Create Schema
  const UserSchema = new Schema({});
  ```

- 创建集合规则：登录和注册时，需要什么，就在Schema对象中写什么(暂时先马马虎虎写一下，最后再修改)

  ```js
  // Create Schema
  const UserSchema = new Schema({
    name: {
      type: String,
      required: true,
    },
    email: {
      type: String,
      required: true,
    },
    password: {
      type: String,
      required: true,
    },
    avatar: {
      type: String,
    },
    date: {
      type: Date,
      default: Date.now
    }
  });
  ```

- 最后使用使用规则创建集合，并暴露出去

  model里的参数：（集合名称，集合规则）

  ```js
  module.exports = User = mongoose.model("users", UserSchema);
  ```

↓

搭建用户登录页面的register接口：

- 因为注册的时候一定会传递一些对应信息，所以要改用post请求

- 安装第三方模块 bodyParser -- npm install body-parser

- 在入口文件中引入body-parser：const bodyParser = **require**("body-parser");

- // *使用body-parser中间件*

  app.**use**(bodyParser.**urlencoded**({ extended: **false** }));

  app.**use**(bodyParser.**json**());

- 在路由user.js中引入User模块，添加post请求

  ```js
  // $route GET api/users/register
  // @desc  返回请求的json数据
  // @access public
  router.post("/register", (req, res) => {
    // console.log(req.body);
    //查询数据库中是否拥有邮箱
    User.findOne({ email: req.body.email }).then((user) => {
      if (user) {
        return res.status(400).json({ email: "邮箱已被注册" });
      } else {
        const newUser = new User({
          name: req.body.name,
          email: req.body.email,
          avatar: avatar,
          password: req.body.password,
        });
      }
    });
  });
  ```

- 如果要给密码，需要安装bcrypt----npm install bcrypt，并在当前文件引入

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpdbj59j30v90acdhk.jpg)

  ```js
  // 给密码加密
  bcrypt.genSalt(10, function (err, salt) {
    bcrypt.hash(newUser.password, salt, (err, hash) => {
      if (err) throw err; // 如果出错了 直接抛出错误
      newUser.password = hash;  // 密码变成hash值
      newUser
        .save()   //调用save存储数据
        .then(user => res.json(user))       //并且但会json对象
        .catch((err) => console.log(err));   //如果错误则打印错误
    });
  });
  ```

- 测试下是否能讲当前数据存到数据库中
  出现报错 ：

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpem9jwj30no03smxs.jpg)

  解决：可能是无法识别ES6语法，把箭头函数改为普通函数, thow err 改为 return err

  ```js
  bcrypt.hash(newUser.password, 10, function (err, hash) {
    if (err) {
      return err;
    }
    newUser.password = hash;
    newUser
      .save()
      .then((user) => res.json(user))
      .catch((err) => console.log(err));
  });
  ```

  运行后可在postman中拿到加密过后的数据
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpe2o0wj30iy04n0t4.jpg)

  完整的请求👇
  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwf820ayxj30ds069wex.jpg" style="zoom:150%;" />

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwf8e38r3j30bi065jrq.jpg" style="zoom:150%;" />

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwf920x46j30vy02dq32.jpg" style="zoom:200%;" />

- 来到MongoDB Compass的控制面板里，查看数据库中新增了test目录，里面保存了users，数据已经传上来啦~

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfpfyvznj30rk0dmabj.jpg)

↓

关于头像的问题avartar---使用第三方gravatar

- npm install gravatar

- 在需要使用的地方（users.js)中引入，const gravatar = **require**("gravatar");

- 在newUser之前，定义avatar先 
  (官网copy)：

  - url代表gravatar下的一个方法，接受2个参数，第一个是用户邮箱，第二个是一些options，
    - s: size
    - r:rating   （可能是一种图片的参数）
    - d:default

  ```js
  var url = gravatar.url('emerleite@gmail.com', {s: '200', r: 'pg', d: '404'});
  ```

  - 对代码稍作改动

    ```js
    const avatar = gravatar.url("req.body.email", {
            s: "200",
            r: "pg",
            d: "mm",
          });
    ```

- 在postman中用一个新邮箱测试一下，此时已经拿到了avatar的地址
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwfzpzvmkj30jj050dgg.jpg)

  这个地址显示的图像是介个样子👉<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwg23njtcj305p05smwy.jpg" style="zoom:80%;" />

  如果用真实的，设置过avatar头像的邮箱来做avatar请求，则会拿到你真实的头像哦~



↓

搭建登录接口：

- 继续在users.js里添加登录接口，此时要求返回token， jwt passport

- 拿到email和password之后与数据库进行匹配， 密码匹配这里用到了bcrypt里面的compare
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgktc25vj30o203n74q.jpg)

  ```js
  bcrypt.compare(password, user.password).then((isMatch) => {
    if (isMatch) {
      res.json({ msg: "success" });
    } else {
      return res.status(400).json({ password: "密码错误" });
    }
  });
  ```

  先不做token，在res.json里直接返回msg, 看下能否在邮箱正确，错误，密码正确，错误的情况下能否正确返回：

  正确情况下👇：
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgqxb9xzj30fu0b4dg9.jpg)
  邮箱错误👇：
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgsmr166j30e509wt91.jpg)

  密码错误👇：

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwgt8vdvsj30du0a6glx.jpg)

- 返回token：

  - npm install jsonwebtoken

  - 引入jsonwebtoken，起名jwt

  - 调用jwt.sign方法，传递相应规则：        jwt.**sign**("规则", "加密名字", "过期时间", "箭头函数");
    加密名字secret可以在keys里面提前定义好:  secretOrKey: "secret",
    ↓

    ```js
    bcrypt.compare(password, user.password).then((isMatch) => {
      if (isMatch) {
        const rule = { id: user.id, name: user.name };
        jwt.sign(rule, keys.secretOrKey, { expiresIn: 3600 }, (err, token) => {
          if (err) throw err;
          res.json({
            success: true,
            token: "Bearer " + token,   //Bearer后有一个空格
          });
        });
      } else {
        return res.status(400).json({ password: "密码错误" });
      }
    });
    ```

  - 调试下~ ok~拿到token

    ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwi4bgprmj30ok0c3dh4.jpg)

↓

验证token：

- ```js
  // $route GET api/users/current
  // @desc  return current user
  // @access private
  router.get("/current", "验证token", (req, res) => {
    res.json({ msg: "success" });
  });
  ```

- 用到passport来验证token

  - npm install passport  passport-jwt

  - 在入口文件中先引入passport， 并初始化passport：app.use(passport.initialize())

    ```js
    // passport 初始化
    app.use(passport.initialize());
    // 引入passport.js代码，同时把上面const的passport传递，这样直接把代码写在passport.js里
    require("./config/passport")(passport);
    ```

  - 在另外单独文件夹中配置passport

    - config-->新建passport.js , 在passport-jwt官网下引入相关配置

  ```js
  const JwtStrategy = require("passport-jwt").Strategy,
    ExtractJwt = require("passport-jwt").ExtractJwt;
  const mongoose = require("mongoose");
  const User = mongoose.model("users");
  
  const keys = require("../config/keys");
  
  const opts = {};
  opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();
  opts.secretOrKey = keys.secretOrKey;
  
  module.exports = (passport) => {};
  ```

  ↓

  ```js
  module.exports = (passport) => {
    passport.use(
      new JwtStrategy(opts, (jwt_payload, done) => {
        console.log(jwt_payload);
      })
    );
  };
  ```

  ↓

  配置完成，来到users.js 引入passport后，添加接口

  ```js
  // $route GET api/users/current
  // @desc  return current user
  // @access private
  router.get(
    "/current",
    passport.authenticate("jwt", { session: false }),
    (req, res) => {
      res.json({ msg: "success" });
    }
  );
  ```

  将刚拿到的token，放到current接口的header中，测试一下，终端会返回，因为在passport.use里我们写了console.log~  👆
  👇
  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwi70e0u2j30ae03k749.jpg)


  ↓

  既然拿到了数据，就可以通过查询后返回用户信息

  ```js
  module.exports = (passport) => {
    passport.use(
      new JwtStrategy(opts, (jwt_payload, done) => {
        console.log(jwt_payload);
        User.findById(jwt_payload.id)
          .then((user) => {
            if (user) {
              return DOMError(null, user);
            }
            return done(null, false);
          })
          .catch((err) => console.log(err));
      })
    );
  };
  ```

  ↓

  调整下返回的代码，只返回user对象中的id,name, email 

  ```js
  // $route GET api/users/current
  // @desc  return current user
  // @access private
  router.get(
    "/current",
    passport.authenticate("jwt", { session: false }),
    (req, res) => {
      res.json({
        id: req.user.id,
        name: req.user.name,
        email: req.user.email,
      });
    }
  );
  ```

  

↓

增加身份字段，添加权限（项目中用不到权限管理的可以忽略这一步）

- 在User.js里添加identity字段
- 在users.js 接口文件中的newUser中补上identity
- 在登录接口位置，在isMath规则处和res.json处添加identity

↓

login、register、current 三个接口测试通过
![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjusnjrvj30l00f9q4l.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjv4a1roj30na0eegnj.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjwn1ssbj30kg04amxd.jpg)

↓
明天继续~ 晚安🐶